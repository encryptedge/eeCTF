schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""Bans issued to users"""
type bans {
  created_at: timestamptz!
  id: bigint!
  ip: String!
  updated_at: timestamptz!

  """An object relationship"""
  user: users!
  user_id: bigint!
}

"""
aggregated selection of "bans"
"""
type bans_aggregate {
  aggregate: bans_aggregate_fields
  nodes: [bans!]!
}

input bans_aggregate_bool_exp {
  count: bans_aggregate_bool_exp_count
}

input bans_aggregate_bool_exp_count {
  arguments: [bans_select_column!]
  distinct: Boolean
  filter: bans_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "bans"
"""
type bans_aggregate_fields {
  avg: bans_avg_fields
  count(columns: [bans_select_column!], distinct: Boolean): Int!
  max: bans_max_fields
  min: bans_min_fields
  stddev: bans_stddev_fields
  stddev_pop: bans_stddev_pop_fields
  stddev_samp: bans_stddev_samp_fields
  sum: bans_sum_fields
  var_pop: bans_var_pop_fields
  var_samp: bans_var_samp_fields
  variance: bans_variance_fields
}

"""
order by aggregate values of table "bans"
"""
input bans_aggregate_order_by {
  avg: bans_avg_order_by
  count: order_by
  max: bans_max_order_by
  min: bans_min_order_by
  stddev: bans_stddev_order_by
  stddev_pop: bans_stddev_pop_order_by
  stddev_samp: bans_stddev_samp_order_by
  sum: bans_sum_order_by
  var_pop: bans_var_pop_order_by
  var_samp: bans_var_samp_order_by
  variance: bans_variance_order_by
}

"""
input type for inserting array relation for remote table "bans"
"""
input bans_arr_rel_insert_input {
  data: [bans_insert_input!]!

  """upsert condition"""
  on_conflict: bans_on_conflict
}

"""aggregate avg on columns"""
type bans_avg_fields {
  id: Float
  user_id: Float
}

"""
order by avg() on columns of table "bans"
"""
input bans_avg_order_by {
  id: order_by
  user_id: order_by
}

"""
Boolean expression to filter rows from the table "bans". All fields are combined with a logical 'AND'.
"""
input bans_bool_exp {
  _and: [bans_bool_exp!]
  _not: bans_bool_exp
  _or: [bans_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: bigint_comparison_exp
  ip: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: bigint_comparison_exp
}

"""
unique or primary key constraints on table "bans"
"""
enum bans_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  bans_pkey
}

"""
input type for incrementing numeric columns in table "bans"
"""
input bans_inc_input {
  id: bigint
  user_id: bigint
}

"""
input type for inserting data into table "bans"
"""
input bans_insert_input {
  created_at: timestamptz
  id: bigint
  ip: String
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: bigint
}

"""aggregate max on columns"""
type bans_max_fields {
  created_at: timestamptz
  id: bigint
  ip: String
  updated_at: timestamptz
  user_id: bigint
}

"""
order by max() on columns of table "bans"
"""
input bans_max_order_by {
  created_at: order_by
  id: order_by
  ip: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type bans_min_fields {
  created_at: timestamptz
  id: bigint
  ip: String
  updated_at: timestamptz
  user_id: bigint
}

"""
order by min() on columns of table "bans"
"""
input bans_min_order_by {
  created_at: order_by
  id: order_by
  ip: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "bans"
"""
type bans_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [bans!]!
}

"""
on_conflict condition type for table "bans"
"""
input bans_on_conflict {
  constraint: bans_constraint!
  update_columns: [bans_update_column!]! = []
  where: bans_bool_exp
}

"""Ordering options when selecting data from "bans"."""
input bans_order_by {
  created_at: order_by
  id: order_by
  ip: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: bans"""
input bans_pk_columns_input {
  id: bigint!
}

"""
select columns of table "bans"
"""
enum bans_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  ip

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "bans"
"""
input bans_set_input {
  created_at: timestamptz
  id: bigint
  ip: String
  updated_at: timestamptz
  user_id: bigint
}

"""aggregate stddev on columns"""
type bans_stddev_fields {
  id: Float
  user_id: Float
}

"""
order by stddev() on columns of table "bans"
"""
input bans_stddev_order_by {
  id: order_by
  user_id: order_by
}

"""aggregate stddev_pop on columns"""
type bans_stddev_pop_fields {
  id: Float
  user_id: Float
}

"""
order by stddev_pop() on columns of table "bans"
"""
input bans_stddev_pop_order_by {
  id: order_by
  user_id: order_by
}

"""aggregate stddev_samp on columns"""
type bans_stddev_samp_fields {
  id: Float
  user_id: Float
}

"""
order by stddev_samp() on columns of table "bans"
"""
input bans_stddev_samp_order_by {
  id: order_by
  user_id: order_by
}

"""
Streaming cursor of the table "bans"
"""
input bans_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: bans_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input bans_stream_cursor_value_input {
  created_at: timestamptz
  id: bigint
  ip: String
  updated_at: timestamptz
  user_id: bigint
}

"""aggregate sum on columns"""
type bans_sum_fields {
  id: bigint
  user_id: bigint
}

"""
order by sum() on columns of table "bans"
"""
input bans_sum_order_by {
  id: order_by
  user_id: order_by
}

"""
update columns of table "bans"
"""
enum bans_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  ip

  """column name"""
  updated_at

  """column name"""
  user_id
}

input bans_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: bans_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: bans_set_input

  """filter the rows which have to be updated"""
  where: bans_bool_exp!
}

"""aggregate var_pop on columns"""
type bans_var_pop_fields {
  id: Float
  user_id: Float
}

"""
order by var_pop() on columns of table "bans"
"""
input bans_var_pop_order_by {
  id: order_by
  user_id: order_by
}

"""aggregate var_samp on columns"""
type bans_var_samp_fields {
  id: Float
  user_id: Float
}

"""
order by var_samp() on columns of table "bans"
"""
input bans_var_samp_order_by {
  id: order_by
  user_id: order_by
}

"""aggregate variance on columns"""
type bans_variance_fields {
  id: Float
  user_id: Float
}

"""
order by variance() on columns of table "bans"
"""
input bans_variance_order_by {
  id: order_by
  user_id: order_by
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""Challenges Data"""
type challenges {
  created_at: timestamptz!
  description: String!
  flag: String!
  id: bigint!

  """An object relationship"""
  machine: machines!
  machine_id: bigint!
  name: String!
  point: Int!

  """An array relationship"""
  scores(
    """distinct select on columns"""
    distinct_on: [scores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scores_order_by!]

    """filter the rows returned"""
    where: scores_bool_exp
  ): [scores!]!

  """An aggregate relationship"""
  scores_aggregate(
    """distinct select on columns"""
    distinct_on: [scores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scores_order_by!]

    """filter the rows returned"""
    where: scores_bool_exp
  ): scores_aggregate!
  stage: Int!

  """An array relationship"""
  submissions(
    """distinct select on columns"""
    distinct_on: [submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submissions_order_by!]

    """filter the rows returned"""
    where: submissions_bool_exp
  ): [submissions!]!

  """An aggregate relationship"""
  submissions_aggregate(
    """distinct select on columns"""
    distinct_on: [submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submissions_order_by!]

    """filter the rows returned"""
    where: submissions_bool_exp
  ): submissions_aggregate!
  updated_at: timestamptz!
}

"""
aggregated selection of "challenges"
"""
type challenges_aggregate {
  aggregate: challenges_aggregate_fields
  nodes: [challenges!]!
}

input challenges_aggregate_bool_exp {
  count: challenges_aggregate_bool_exp_count
}

input challenges_aggregate_bool_exp_count {
  arguments: [challenges_select_column!]
  distinct: Boolean
  filter: challenges_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "challenges"
"""
type challenges_aggregate_fields {
  avg: challenges_avg_fields
  count(columns: [challenges_select_column!], distinct: Boolean): Int!
  max: challenges_max_fields
  min: challenges_min_fields
  stddev: challenges_stddev_fields
  stddev_pop: challenges_stddev_pop_fields
  stddev_samp: challenges_stddev_samp_fields
  sum: challenges_sum_fields
  var_pop: challenges_var_pop_fields
  var_samp: challenges_var_samp_fields
  variance: challenges_variance_fields
}

"""
order by aggregate values of table "challenges"
"""
input challenges_aggregate_order_by {
  avg: challenges_avg_order_by
  count: order_by
  max: challenges_max_order_by
  min: challenges_min_order_by
  stddev: challenges_stddev_order_by
  stddev_pop: challenges_stddev_pop_order_by
  stddev_samp: challenges_stddev_samp_order_by
  sum: challenges_sum_order_by
  var_pop: challenges_var_pop_order_by
  var_samp: challenges_var_samp_order_by
  variance: challenges_variance_order_by
}

"""
input type for inserting array relation for remote table "challenges"
"""
input challenges_arr_rel_insert_input {
  data: [challenges_insert_input!]!

  """upsert condition"""
  on_conflict: challenges_on_conflict
}

"""aggregate avg on columns"""
type challenges_avg_fields {
  id: Float
  machine_id: Float
  point: Float
  stage: Float
}

"""
order by avg() on columns of table "challenges"
"""
input challenges_avg_order_by {
  id: order_by
  machine_id: order_by
  point: order_by
  stage: order_by
}

"""
Boolean expression to filter rows from the table "challenges". All fields are combined with a logical 'AND'.
"""
input challenges_bool_exp {
  _and: [challenges_bool_exp!]
  _not: challenges_bool_exp
  _or: [challenges_bool_exp!]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  flag: String_comparison_exp
  id: bigint_comparison_exp
  machine: machines_bool_exp
  machine_id: bigint_comparison_exp
  name: String_comparison_exp
  point: Int_comparison_exp
  scores: scores_bool_exp
  scores_aggregate: scores_aggregate_bool_exp
  stage: Int_comparison_exp
  submissions: submissions_bool_exp
  submissions_aggregate: submissions_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "challenges"
"""
enum challenges_constraint {
  """
  unique or primary key constraint on columns "flag"
  """
  challenges_flag_key

  """
  unique or primary key constraint on columns "name"
  """
  challenges_name_key

  """
  unique or primary key constraint on columns "id"
  """
  challenges_pkey
}

"""
input type for incrementing numeric columns in table "challenges"
"""
input challenges_inc_input {
  id: bigint
  machine_id: bigint
  point: Int
  stage: Int
}

"""
input type for inserting data into table "challenges"
"""
input challenges_insert_input {
  created_at: timestamptz
  description: String
  flag: String
  id: bigint
  machine: machines_obj_rel_insert_input
  machine_id: bigint
  name: String
  point: Int
  scores: scores_arr_rel_insert_input
  stage: Int
  submissions: submissions_arr_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type challenges_max_fields {
  created_at: timestamptz
  description: String
  flag: String
  id: bigint
  machine_id: bigint
  name: String
  point: Int
  stage: Int
  updated_at: timestamptz
}

"""
order by max() on columns of table "challenges"
"""
input challenges_max_order_by {
  created_at: order_by
  description: order_by
  flag: order_by
  id: order_by
  machine_id: order_by
  name: order_by
  point: order_by
  stage: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type challenges_min_fields {
  created_at: timestamptz
  description: String
  flag: String
  id: bigint
  machine_id: bigint
  name: String
  point: Int
  stage: Int
  updated_at: timestamptz
}

"""
order by min() on columns of table "challenges"
"""
input challenges_min_order_by {
  created_at: order_by
  description: order_by
  flag: order_by
  id: order_by
  machine_id: order_by
  name: order_by
  point: order_by
  stage: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "challenges"
"""
type challenges_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [challenges!]!
}

"""
input type for inserting object relation for remote table "challenges"
"""
input challenges_obj_rel_insert_input {
  data: challenges_insert_input!

  """upsert condition"""
  on_conflict: challenges_on_conflict
}

"""
on_conflict condition type for table "challenges"
"""
input challenges_on_conflict {
  constraint: challenges_constraint!
  update_columns: [challenges_update_column!]! = []
  where: challenges_bool_exp
}

"""Ordering options when selecting data from "challenges"."""
input challenges_order_by {
  created_at: order_by
  description: order_by
  flag: order_by
  id: order_by
  machine: machines_order_by
  machine_id: order_by
  name: order_by
  point: order_by
  scores_aggregate: scores_aggregate_order_by
  stage: order_by
  submissions_aggregate: submissions_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: challenges"""
input challenges_pk_columns_input {
  id: bigint!
}

"""
select columns of table "challenges"
"""
enum challenges_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  flag

  """column name"""
  id

  """column name"""
  machine_id

  """column name"""
  name

  """column name"""
  point

  """column name"""
  stage

  """column name"""
  updated_at
}

"""
input type for updating data in table "challenges"
"""
input challenges_set_input {
  created_at: timestamptz
  description: String
  flag: String
  id: bigint
  machine_id: bigint
  name: String
  point: Int
  stage: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type challenges_stddev_fields {
  id: Float
  machine_id: Float
  point: Float
  stage: Float
}

"""
order by stddev() on columns of table "challenges"
"""
input challenges_stddev_order_by {
  id: order_by
  machine_id: order_by
  point: order_by
  stage: order_by
}

"""aggregate stddev_pop on columns"""
type challenges_stddev_pop_fields {
  id: Float
  machine_id: Float
  point: Float
  stage: Float
}

"""
order by stddev_pop() on columns of table "challenges"
"""
input challenges_stddev_pop_order_by {
  id: order_by
  machine_id: order_by
  point: order_by
  stage: order_by
}

"""aggregate stddev_samp on columns"""
type challenges_stddev_samp_fields {
  id: Float
  machine_id: Float
  point: Float
  stage: Float
}

"""
order by stddev_samp() on columns of table "challenges"
"""
input challenges_stddev_samp_order_by {
  id: order_by
  machine_id: order_by
  point: order_by
  stage: order_by
}

"""
Streaming cursor of the table "challenges"
"""
input challenges_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: challenges_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input challenges_stream_cursor_value_input {
  created_at: timestamptz
  description: String
  flag: String
  id: bigint
  machine_id: bigint
  name: String
  point: Int
  stage: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type challenges_sum_fields {
  id: bigint
  machine_id: bigint
  point: Int
  stage: Int
}

"""
order by sum() on columns of table "challenges"
"""
input challenges_sum_order_by {
  id: order_by
  machine_id: order_by
  point: order_by
  stage: order_by
}

"""
update columns of table "challenges"
"""
enum challenges_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  flag

  """column name"""
  id

  """column name"""
  machine_id

  """column name"""
  name

  """column name"""
  point

  """column name"""
  stage

  """column name"""
  updated_at
}

input challenges_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: challenges_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: challenges_set_input

  """filter the rows which have to be updated"""
  where: challenges_bool_exp!
}

"""aggregate var_pop on columns"""
type challenges_var_pop_fields {
  id: Float
  machine_id: Float
  point: Float
  stage: Float
}

"""
order by var_pop() on columns of table "challenges"
"""
input challenges_var_pop_order_by {
  id: order_by
  machine_id: order_by
  point: order_by
  stage: order_by
}

"""aggregate var_samp on columns"""
type challenges_var_samp_fields {
  id: Float
  machine_id: Float
  point: Float
  stage: Float
}

"""
order by var_samp() on columns of table "challenges"
"""
input challenges_var_samp_order_by {
  id: order_by
  machine_id: order_by
  point: order_by
  stage: order_by
}

"""aggregate variance on columns"""
type challenges_variance_fields {
  id: Float
  machine_id: Float
  point: Float
  stage: Float
}

"""
order by variance() on columns of table "challenges"
"""
input challenges_variance_order_by {
  id: order_by
  machine_id: order_by
  point: order_by
  stage: order_by
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""Machines Data"""
type machines {
  """An array relationship"""
  challenges(
    """distinct select on columns"""
    distinct_on: [challenges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenges_order_by!]

    """filter the rows returned"""
    where: challenges_bool_exp
  ): [challenges!]!

  """An aggregate relationship"""
  challenges_aggregate(
    """distinct select on columns"""
    distinct_on: [challenges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenges_order_by!]

    """filter the rows returned"""
    where: challenges_bool_exp
  ): challenges_aggregate!
  created_at: timestamptz!
  created_by: String!
  description: String!
  id: bigint!
  name: String!
  no_of_solves: Int!
  tags: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "machines"
"""
type machines_aggregate {
  aggregate: machines_aggregate_fields
  nodes: [machines!]!
}

"""
aggregate fields of "machines"
"""
type machines_aggregate_fields {
  avg: machines_avg_fields
  count(columns: [machines_select_column!], distinct: Boolean): Int!
  max: machines_max_fields
  min: machines_min_fields
  stddev: machines_stddev_fields
  stddev_pop: machines_stddev_pop_fields
  stddev_samp: machines_stddev_samp_fields
  sum: machines_sum_fields
  var_pop: machines_var_pop_fields
  var_samp: machines_var_samp_fields
  variance: machines_variance_fields
}

"""aggregate avg on columns"""
type machines_avg_fields {
  id: Float
  no_of_solves: Float
}

"""
Boolean expression to filter rows from the table "machines". All fields are combined with a logical 'AND'.
"""
input machines_bool_exp {
  _and: [machines_bool_exp!]
  _not: machines_bool_exp
  _or: [machines_bool_exp!]
  challenges: challenges_bool_exp
  challenges_aggregate: challenges_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  created_by: String_comparison_exp
  description: String_comparison_exp
  id: bigint_comparison_exp
  name: String_comparison_exp
  no_of_solves: Int_comparison_exp
  tags: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "machines"
"""
enum machines_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  machines_name_key

  """
  unique or primary key constraint on columns "id"
  """
  machines_pkey
}

"""
input type for incrementing numeric columns in table "machines"
"""
input machines_inc_input {
  id: bigint
  no_of_solves: Int
}

"""
input type for inserting data into table "machines"
"""
input machines_insert_input {
  challenges: challenges_arr_rel_insert_input
  created_at: timestamptz
  created_by: String
  description: String
  id: bigint
  name: String
  no_of_solves: Int
  tags: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type machines_max_fields {
  created_at: timestamptz
  created_by: String
  description: String
  id: bigint
  name: String
  no_of_solves: Int
  tags: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type machines_min_fields {
  created_at: timestamptz
  created_by: String
  description: String
  id: bigint
  name: String
  no_of_solves: Int
  tags: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "machines"
"""
type machines_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [machines!]!
}

"""
input type for inserting object relation for remote table "machines"
"""
input machines_obj_rel_insert_input {
  data: machines_insert_input!

  """upsert condition"""
  on_conflict: machines_on_conflict
}

"""
on_conflict condition type for table "machines"
"""
input machines_on_conflict {
  constraint: machines_constraint!
  update_columns: [machines_update_column!]! = []
  where: machines_bool_exp
}

"""Ordering options when selecting data from "machines"."""
input machines_order_by {
  challenges_aggregate: challenges_aggregate_order_by
  created_at: order_by
  created_by: order_by
  description: order_by
  id: order_by
  name: order_by
  no_of_solves: order_by
  tags: order_by
  updated_at: order_by
}

"""primary key columns input for table: machines"""
input machines_pk_columns_input {
  id: bigint!
}

"""
select columns of table "machines"
"""
enum machines_select_column {
  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  no_of_solves

  """column name"""
  tags

  """column name"""
  updated_at
}

"""
input type for updating data in table "machines"
"""
input machines_set_input {
  created_at: timestamptz
  created_by: String
  description: String
  id: bigint
  name: String
  no_of_solves: Int
  tags: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type machines_stddev_fields {
  id: Float
  no_of_solves: Float
}

"""aggregate stddev_pop on columns"""
type machines_stddev_pop_fields {
  id: Float
  no_of_solves: Float
}

"""aggregate stddev_samp on columns"""
type machines_stddev_samp_fields {
  id: Float
  no_of_solves: Float
}

"""
Streaming cursor of the table "machines"
"""
input machines_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: machines_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input machines_stream_cursor_value_input {
  created_at: timestamptz
  created_by: String
  description: String
  id: bigint
  name: String
  no_of_solves: Int
  tags: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type machines_sum_fields {
  id: bigint
  no_of_solves: Int
}

"""
update columns of table "machines"
"""
enum machines_update_column {
  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  no_of_solves

  """column name"""
  tags

  """column name"""
  updated_at
}

input machines_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: machines_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: machines_set_input

  """filter the rows which have to be updated"""
  where: machines_bool_exp!
}

"""aggregate var_pop on columns"""
type machines_var_pop_fields {
  id: Float
  no_of_solves: Float
}

"""aggregate var_samp on columns"""
type machines_var_samp_fields {
  id: Float
  no_of_solves: Float
}

"""aggregate variance on columns"""
type machines_variance_fields {
  id: Float
  no_of_solves: Float
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "bans"
  """
  delete_bans(
    """filter the rows which have to be deleted"""
    where: bans_bool_exp!
  ): bans_mutation_response

  """
  delete single row from the table: "bans"
  """
  delete_bans_by_pk(id: bigint!): bans

  """
  delete data from the table: "challenges"
  """
  delete_challenges(
    """filter the rows which have to be deleted"""
    where: challenges_bool_exp!
  ): challenges_mutation_response

  """
  delete single row from the table: "challenges"
  """
  delete_challenges_by_pk(id: bigint!): challenges

  """
  delete data from the table: "machines"
  """
  delete_machines(
    """filter the rows which have to be deleted"""
    where: machines_bool_exp!
  ): machines_mutation_response

  """
  delete single row from the table: "machines"
  """
  delete_machines_by_pk(id: bigint!): machines

  """
  delete data from the table: "scores"
  """
  delete_scores(
    """filter the rows which have to be deleted"""
    where: scores_bool_exp!
  ): scores_mutation_response

  """
  delete single row from the table: "scores"
  """
  delete_scores_by_pk(id: bigint!): scores

  """
  delete data from the table: "submissions"
  """
  delete_submissions(
    """filter the rows which have to be deleted"""
    where: submissions_bool_exp!
  ): submissions_mutation_response

  """
  delete single row from the table: "submissions"
  """
  delete_submissions_by_pk(id: bigint!): submissions

  """
  delete data from the table: "teams"
  """
  delete_teams(
    """filter the rows which have to be deleted"""
    where: teams_bool_exp!
  ): teams_mutation_response

  """
  delete single row from the table: "teams"
  """
  delete_teams_by_pk(id: bigint!): teams

  """
  delete data from the table: "users"
  """
  delete_users(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "users"
  """
  delete_users_by_pk(id: bigint!): users

  """
  insert data into the table: "bans"
  """
  insert_bans(
    """the rows to be inserted"""
    objects: [bans_insert_input!]!

    """upsert condition"""
    on_conflict: bans_on_conflict
  ): bans_mutation_response

  """
  insert a single row into the table: "bans"
  """
  insert_bans_one(
    """the row to be inserted"""
    object: bans_insert_input!

    """upsert condition"""
    on_conflict: bans_on_conflict
  ): bans

  """
  insert data into the table: "challenges"
  """
  insert_challenges(
    """the rows to be inserted"""
    objects: [challenges_insert_input!]!

    """upsert condition"""
    on_conflict: challenges_on_conflict
  ): challenges_mutation_response

  """
  insert a single row into the table: "challenges"
  """
  insert_challenges_one(
    """the row to be inserted"""
    object: challenges_insert_input!

    """upsert condition"""
    on_conflict: challenges_on_conflict
  ): challenges

  """
  insert data into the table: "machines"
  """
  insert_machines(
    """the rows to be inserted"""
    objects: [machines_insert_input!]!

    """upsert condition"""
    on_conflict: machines_on_conflict
  ): machines_mutation_response

  """
  insert a single row into the table: "machines"
  """
  insert_machines_one(
    """the row to be inserted"""
    object: machines_insert_input!

    """upsert condition"""
    on_conflict: machines_on_conflict
  ): machines

  """
  insert data into the table: "scores"
  """
  insert_scores(
    """the rows to be inserted"""
    objects: [scores_insert_input!]!

    """upsert condition"""
    on_conflict: scores_on_conflict
  ): scores_mutation_response

  """
  insert a single row into the table: "scores"
  """
  insert_scores_one(
    """the row to be inserted"""
    object: scores_insert_input!

    """upsert condition"""
    on_conflict: scores_on_conflict
  ): scores

  """
  insert data into the table: "submissions"
  """
  insert_submissions(
    """the rows to be inserted"""
    objects: [submissions_insert_input!]!

    """upsert condition"""
    on_conflict: submissions_on_conflict
  ): submissions_mutation_response

  """
  insert a single row into the table: "submissions"
  """
  insert_submissions_one(
    """the row to be inserted"""
    object: submissions_insert_input!

    """upsert condition"""
    on_conflict: submissions_on_conflict
  ): submissions

  """
  insert data into the table: "teams"
  """
  insert_teams(
    """the rows to be inserted"""
    objects: [teams_insert_input!]!

    """upsert condition"""
    on_conflict: teams_on_conflict
  ): teams_mutation_response

  """
  insert a single row into the table: "teams"
  """
  insert_teams_one(
    """the row to be inserted"""
    object: teams_insert_input!

    """upsert condition"""
    on_conflict: teams_on_conflict
  ): teams

  """
  insert data into the table: "users"
  """
  insert_users(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "users"
  """
  insert_users_one(
    """the row to be inserted"""
    object: users_insert_input!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users

  """
  update data of the table: "bans"
  """
  update_bans(
    """increments the numeric columns with given value of the filtered values"""
    _inc: bans_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: bans_set_input

    """filter the rows which have to be updated"""
    where: bans_bool_exp!
  ): bans_mutation_response

  """
  update single row of the table: "bans"
  """
  update_bans_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: bans_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: bans_set_input
    pk_columns: bans_pk_columns_input!
  ): bans

  """
  update multiples rows of table: "bans"
  """
  update_bans_many(
    """updates to execute, in order"""
    updates: [bans_updates!]!
  ): [bans_mutation_response]

  """
  update data of the table: "challenges"
  """
  update_challenges(
    """increments the numeric columns with given value of the filtered values"""
    _inc: challenges_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: challenges_set_input

    """filter the rows which have to be updated"""
    where: challenges_bool_exp!
  ): challenges_mutation_response

  """
  update single row of the table: "challenges"
  """
  update_challenges_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: challenges_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: challenges_set_input
    pk_columns: challenges_pk_columns_input!
  ): challenges

  """
  update multiples rows of table: "challenges"
  """
  update_challenges_many(
    """updates to execute, in order"""
    updates: [challenges_updates!]!
  ): [challenges_mutation_response]

  """
  update data of the table: "machines"
  """
  update_machines(
    """increments the numeric columns with given value of the filtered values"""
    _inc: machines_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: machines_set_input

    """filter the rows which have to be updated"""
    where: machines_bool_exp!
  ): machines_mutation_response

  """
  update single row of the table: "machines"
  """
  update_machines_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: machines_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: machines_set_input
    pk_columns: machines_pk_columns_input!
  ): machines

  """
  update multiples rows of table: "machines"
  """
  update_machines_many(
    """updates to execute, in order"""
    updates: [machines_updates!]!
  ): [machines_mutation_response]

  """
  update data of the table: "scores"
  """
  update_scores(
    """increments the numeric columns with given value of the filtered values"""
    _inc: scores_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: scores_set_input

    """filter the rows which have to be updated"""
    where: scores_bool_exp!
  ): scores_mutation_response

  """
  update single row of the table: "scores"
  """
  update_scores_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: scores_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: scores_set_input
    pk_columns: scores_pk_columns_input!
  ): scores

  """
  update multiples rows of table: "scores"
  """
  update_scores_many(
    """updates to execute, in order"""
    updates: [scores_updates!]!
  ): [scores_mutation_response]

  """
  update data of the table: "submissions"
  """
  update_submissions(
    """increments the numeric columns with given value of the filtered values"""
    _inc: submissions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: submissions_set_input

    """filter the rows which have to be updated"""
    where: submissions_bool_exp!
  ): submissions_mutation_response

  """
  update single row of the table: "submissions"
  """
  update_submissions_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: submissions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: submissions_set_input
    pk_columns: submissions_pk_columns_input!
  ): submissions

  """
  update multiples rows of table: "submissions"
  """
  update_submissions_many(
    """updates to execute, in order"""
    updates: [submissions_updates!]!
  ): [submissions_mutation_response]

  """
  update data of the table: "teams"
  """
  update_teams(
    """increments the numeric columns with given value of the filtered values"""
    _inc: teams_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: teams_set_input

    """filter the rows which have to be updated"""
    where: teams_bool_exp!
  ): teams_mutation_response

  """
  update single row of the table: "teams"
  """
  update_teams_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: teams_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: teams_set_input
    pk_columns: teams_pk_columns_input!
  ): teams

  """
  update multiples rows of table: "teams"
  """
  update_teams_many(
    """updates to execute, in order"""
    updates: [teams_updates!]!
  ): [teams_mutation_response]

  """
  update data of the table: "users"
  """
  update_users(
    """increments the numeric columns with given value of the filtered values"""
    _inc: users_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "users"
  """
  update_users_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: users_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update multiples rows of table: "users"
  """
  update_users_many(
    """updates to execute, in order"""
    updates: [users_updates!]!
  ): [users_mutation_response]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

type query_root {
  """An array relationship"""
  bans(
    """distinct select on columns"""
    distinct_on: [bans_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bans_order_by!]

    """filter the rows returned"""
    where: bans_bool_exp
  ): [bans!]!

  """An aggregate relationship"""
  bans_aggregate(
    """distinct select on columns"""
    distinct_on: [bans_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bans_order_by!]

    """filter the rows returned"""
    where: bans_bool_exp
  ): bans_aggregate!

  """fetch data from the table: "bans" using primary key columns"""
  bans_by_pk(id: bigint!): bans

  """An array relationship"""
  challenges(
    """distinct select on columns"""
    distinct_on: [challenges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenges_order_by!]

    """filter the rows returned"""
    where: challenges_bool_exp
  ): [challenges!]!

  """An aggregate relationship"""
  challenges_aggregate(
    """distinct select on columns"""
    distinct_on: [challenges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenges_order_by!]

    """filter the rows returned"""
    where: challenges_bool_exp
  ): challenges_aggregate!

  """fetch data from the table: "challenges" using primary key columns"""
  challenges_by_pk(id: bigint!): challenges

  """
  fetch data from the table: "machines"
  """
  machines(
    """distinct select on columns"""
    distinct_on: [machines_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [machines_order_by!]

    """filter the rows returned"""
    where: machines_bool_exp
  ): [machines!]!

  """
  fetch aggregated fields from the table: "machines"
  """
  machines_aggregate(
    """distinct select on columns"""
    distinct_on: [machines_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [machines_order_by!]

    """filter the rows returned"""
    where: machines_bool_exp
  ): machines_aggregate!

  """fetch data from the table: "machines" using primary key columns"""
  machines_by_pk(id: bigint!): machines

  """An array relationship"""
  scores(
    """distinct select on columns"""
    distinct_on: [scores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scores_order_by!]

    """filter the rows returned"""
    where: scores_bool_exp
  ): [scores!]!

  """An aggregate relationship"""
  scores_aggregate(
    """distinct select on columns"""
    distinct_on: [scores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scores_order_by!]

    """filter the rows returned"""
    where: scores_bool_exp
  ): scores_aggregate!

  """fetch data from the table: "scores" using primary key columns"""
  scores_by_pk(id: bigint!): scores

  """An array relationship"""
  submissions(
    """distinct select on columns"""
    distinct_on: [submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submissions_order_by!]

    """filter the rows returned"""
    where: submissions_bool_exp
  ): [submissions!]!

  """An aggregate relationship"""
  submissions_aggregate(
    """distinct select on columns"""
    distinct_on: [submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submissions_order_by!]

    """filter the rows returned"""
    where: submissions_bool_exp
  ): submissions_aggregate!

  """fetch data from the table: "submissions" using primary key columns"""
  submissions_by_pk(id: bigint!): submissions

  """
  fetch data from the table: "teams"
  """
  teams(
    """distinct select on columns"""
    distinct_on: [teams_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teams_order_by!]

    """filter the rows returned"""
    where: teams_bool_exp
  ): [teams!]!

  """
  fetch aggregated fields from the table: "teams"
  """
  teams_aggregate(
    """distinct select on columns"""
    distinct_on: [teams_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teams_order_by!]

    """filter the rows returned"""
    where: teams_bool_exp
  ): teams_aggregate!

  """fetch data from the table: "teams" using primary key columns"""
  teams_by_pk(id: bigint!): teams

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: bigint!): users
}

"""Scoreboard Data"""
type scores {
  """An object relationship"""
  challenge: challenges!
  challenge_id: bigint!
  created_at: timestamptz!
  id: bigint!

  """An object relationship"""
  submission: submissions!
  submission_id: bigint!

  """An object relationship"""
  team: teams!
  team_id: bigint!
  updated_at: timestamptz!

  """An object relationship"""
  user: users!
  user_id: bigint!
}

"""
aggregated selection of "scores"
"""
type scores_aggregate {
  aggregate: scores_aggregate_fields
  nodes: [scores!]!
}

input scores_aggregate_bool_exp {
  count: scores_aggregate_bool_exp_count
}

input scores_aggregate_bool_exp_count {
  arguments: [scores_select_column!]
  distinct: Boolean
  filter: scores_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "scores"
"""
type scores_aggregate_fields {
  avg: scores_avg_fields
  count(columns: [scores_select_column!], distinct: Boolean): Int!
  max: scores_max_fields
  min: scores_min_fields
  stddev: scores_stddev_fields
  stddev_pop: scores_stddev_pop_fields
  stddev_samp: scores_stddev_samp_fields
  sum: scores_sum_fields
  var_pop: scores_var_pop_fields
  var_samp: scores_var_samp_fields
  variance: scores_variance_fields
}

"""
order by aggregate values of table "scores"
"""
input scores_aggregate_order_by {
  avg: scores_avg_order_by
  count: order_by
  max: scores_max_order_by
  min: scores_min_order_by
  stddev: scores_stddev_order_by
  stddev_pop: scores_stddev_pop_order_by
  stddev_samp: scores_stddev_samp_order_by
  sum: scores_sum_order_by
  var_pop: scores_var_pop_order_by
  var_samp: scores_var_samp_order_by
  variance: scores_variance_order_by
}

"""
input type for inserting array relation for remote table "scores"
"""
input scores_arr_rel_insert_input {
  data: [scores_insert_input!]!

  """upsert condition"""
  on_conflict: scores_on_conflict
}

"""aggregate avg on columns"""
type scores_avg_fields {
  challenge_id: Float
  id: Float
  submission_id: Float
  team_id: Float
  user_id: Float
}

"""
order by avg() on columns of table "scores"
"""
input scores_avg_order_by {
  challenge_id: order_by
  id: order_by
  submission_id: order_by
  team_id: order_by
  user_id: order_by
}

"""
Boolean expression to filter rows from the table "scores". All fields are combined with a logical 'AND'.
"""
input scores_bool_exp {
  _and: [scores_bool_exp!]
  _not: scores_bool_exp
  _or: [scores_bool_exp!]
  challenge: challenges_bool_exp
  challenge_id: bigint_comparison_exp
  created_at: timestamptz_comparison_exp
  id: bigint_comparison_exp
  submission: submissions_bool_exp
  submission_id: bigint_comparison_exp
  team: teams_bool_exp
  team_id: bigint_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: bigint_comparison_exp
}

"""
unique or primary key constraints on table "scores"
"""
enum scores_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  scores_pkey

  """
  unique or primary key constraint on columns "submission_id"
  """
  scores_submission_id_key
}

"""
input type for incrementing numeric columns in table "scores"
"""
input scores_inc_input {
  challenge_id: bigint
  id: bigint
  submission_id: bigint
  team_id: bigint
  user_id: bigint
}

"""
input type for inserting data into table "scores"
"""
input scores_insert_input {
  challenge: challenges_obj_rel_insert_input
  challenge_id: bigint
  created_at: timestamptz
  id: bigint
  submission: submissions_obj_rel_insert_input
  submission_id: bigint
  team: teams_obj_rel_insert_input
  team_id: bigint
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: bigint
}

"""aggregate max on columns"""
type scores_max_fields {
  challenge_id: bigint
  created_at: timestamptz
  id: bigint
  submission_id: bigint
  team_id: bigint
  updated_at: timestamptz
  user_id: bigint
}

"""
order by max() on columns of table "scores"
"""
input scores_max_order_by {
  challenge_id: order_by
  created_at: order_by
  id: order_by
  submission_id: order_by
  team_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type scores_min_fields {
  challenge_id: bigint
  created_at: timestamptz
  id: bigint
  submission_id: bigint
  team_id: bigint
  updated_at: timestamptz
  user_id: bigint
}

"""
order by min() on columns of table "scores"
"""
input scores_min_order_by {
  challenge_id: order_by
  created_at: order_by
  id: order_by
  submission_id: order_by
  team_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "scores"
"""
type scores_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [scores!]!
}

"""
input type for inserting object relation for remote table "scores"
"""
input scores_obj_rel_insert_input {
  data: scores_insert_input!

  """upsert condition"""
  on_conflict: scores_on_conflict
}

"""
on_conflict condition type for table "scores"
"""
input scores_on_conflict {
  constraint: scores_constraint!
  update_columns: [scores_update_column!]! = []
  where: scores_bool_exp
}

"""Ordering options when selecting data from "scores"."""
input scores_order_by {
  challenge: challenges_order_by
  challenge_id: order_by
  created_at: order_by
  id: order_by
  submission: submissions_order_by
  submission_id: order_by
  team: teams_order_by
  team_id: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: scores"""
input scores_pk_columns_input {
  id: bigint!
}

"""
select columns of table "scores"
"""
enum scores_select_column {
  """column name"""
  challenge_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  submission_id

  """column name"""
  team_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "scores"
"""
input scores_set_input {
  challenge_id: bigint
  created_at: timestamptz
  id: bigint
  submission_id: bigint
  team_id: bigint
  updated_at: timestamptz
  user_id: bigint
}

"""aggregate stddev on columns"""
type scores_stddev_fields {
  challenge_id: Float
  id: Float
  submission_id: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev() on columns of table "scores"
"""
input scores_stddev_order_by {
  challenge_id: order_by
  id: order_by
  submission_id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate stddev_pop on columns"""
type scores_stddev_pop_fields {
  challenge_id: Float
  id: Float
  submission_id: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev_pop() on columns of table "scores"
"""
input scores_stddev_pop_order_by {
  challenge_id: order_by
  id: order_by
  submission_id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate stddev_samp on columns"""
type scores_stddev_samp_fields {
  challenge_id: Float
  id: Float
  submission_id: Float
  team_id: Float
  user_id: Float
}

"""
order by stddev_samp() on columns of table "scores"
"""
input scores_stddev_samp_order_by {
  challenge_id: order_by
  id: order_by
  submission_id: order_by
  team_id: order_by
  user_id: order_by
}

"""
Streaming cursor of the table "scores"
"""
input scores_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: scores_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input scores_stream_cursor_value_input {
  challenge_id: bigint
  created_at: timestamptz
  id: bigint
  submission_id: bigint
  team_id: bigint
  updated_at: timestamptz
  user_id: bigint
}

"""aggregate sum on columns"""
type scores_sum_fields {
  challenge_id: bigint
  id: bigint
  submission_id: bigint
  team_id: bigint
  user_id: bigint
}

"""
order by sum() on columns of table "scores"
"""
input scores_sum_order_by {
  challenge_id: order_by
  id: order_by
  submission_id: order_by
  team_id: order_by
  user_id: order_by
}

"""
update columns of table "scores"
"""
enum scores_update_column {
  """column name"""
  challenge_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  submission_id

  """column name"""
  team_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

input scores_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: scores_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: scores_set_input

  """filter the rows which have to be updated"""
  where: scores_bool_exp!
}

"""aggregate var_pop on columns"""
type scores_var_pop_fields {
  challenge_id: Float
  id: Float
  submission_id: Float
  team_id: Float
  user_id: Float
}

"""
order by var_pop() on columns of table "scores"
"""
input scores_var_pop_order_by {
  challenge_id: order_by
  id: order_by
  submission_id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate var_samp on columns"""
type scores_var_samp_fields {
  challenge_id: Float
  id: Float
  submission_id: Float
  team_id: Float
  user_id: Float
}

"""
order by var_samp() on columns of table "scores"
"""
input scores_var_samp_order_by {
  challenge_id: order_by
  id: order_by
  submission_id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate variance on columns"""
type scores_variance_fields {
  challenge_id: Float
  id: Float
  submission_id: Float
  team_id: Float
  user_id: Float
}

"""
order by variance() on columns of table "scores"
"""
input scores_variance_order_by {
  challenge_id: order_by
  id: order_by
  submission_id: order_by
  team_id: order_by
  user_id: order_by
}

"""User flag submissions"""
type submissions {
  """An object relationship"""
  challenge: challenges!
  challenge_id: bigint!
  created_at: timestamptz!
  id: bigint!

  """An object relationship"""
  score: scores
  submited_flag: String!
  updated_at: timestamptz!

  """An object relationship"""
  user: users!
  user_id: bigint!
}

"""
aggregated selection of "submissions"
"""
type submissions_aggregate {
  aggregate: submissions_aggregate_fields
  nodes: [submissions!]!
}

input submissions_aggregate_bool_exp {
  count: submissions_aggregate_bool_exp_count
}

input submissions_aggregate_bool_exp_count {
  arguments: [submissions_select_column!]
  distinct: Boolean
  filter: submissions_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "submissions"
"""
type submissions_aggregate_fields {
  avg: submissions_avg_fields
  count(columns: [submissions_select_column!], distinct: Boolean): Int!
  max: submissions_max_fields
  min: submissions_min_fields
  stddev: submissions_stddev_fields
  stddev_pop: submissions_stddev_pop_fields
  stddev_samp: submissions_stddev_samp_fields
  sum: submissions_sum_fields
  var_pop: submissions_var_pop_fields
  var_samp: submissions_var_samp_fields
  variance: submissions_variance_fields
}

"""
order by aggregate values of table "submissions"
"""
input submissions_aggregate_order_by {
  avg: submissions_avg_order_by
  count: order_by
  max: submissions_max_order_by
  min: submissions_min_order_by
  stddev: submissions_stddev_order_by
  stddev_pop: submissions_stddev_pop_order_by
  stddev_samp: submissions_stddev_samp_order_by
  sum: submissions_sum_order_by
  var_pop: submissions_var_pop_order_by
  var_samp: submissions_var_samp_order_by
  variance: submissions_variance_order_by
}

"""
input type for inserting array relation for remote table "submissions"
"""
input submissions_arr_rel_insert_input {
  data: [submissions_insert_input!]!

  """upsert condition"""
  on_conflict: submissions_on_conflict
}

"""aggregate avg on columns"""
type submissions_avg_fields {
  challenge_id: Float
  id: Float
  user_id: Float
}

"""
order by avg() on columns of table "submissions"
"""
input submissions_avg_order_by {
  challenge_id: order_by
  id: order_by
  user_id: order_by
}

"""
Boolean expression to filter rows from the table "submissions". All fields are combined with a logical 'AND'.
"""
input submissions_bool_exp {
  _and: [submissions_bool_exp!]
  _not: submissions_bool_exp
  _or: [submissions_bool_exp!]
  challenge: challenges_bool_exp
  challenge_id: bigint_comparison_exp
  created_at: timestamptz_comparison_exp
  id: bigint_comparison_exp
  score: scores_bool_exp
  submited_flag: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: bigint_comparison_exp
}

"""
unique or primary key constraints on table "submissions"
"""
enum submissions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  submissions_pkey
}

"""
input type for incrementing numeric columns in table "submissions"
"""
input submissions_inc_input {
  challenge_id: bigint
  id: bigint
  user_id: bigint
}

"""
input type for inserting data into table "submissions"
"""
input submissions_insert_input {
  challenge: challenges_obj_rel_insert_input
  challenge_id: bigint
  created_at: timestamptz
  id: bigint
  score: scores_obj_rel_insert_input
  submited_flag: String
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: bigint
}

"""aggregate max on columns"""
type submissions_max_fields {
  challenge_id: bigint
  created_at: timestamptz
  id: bigint
  submited_flag: String
  updated_at: timestamptz
  user_id: bigint
}

"""
order by max() on columns of table "submissions"
"""
input submissions_max_order_by {
  challenge_id: order_by
  created_at: order_by
  id: order_by
  submited_flag: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type submissions_min_fields {
  challenge_id: bigint
  created_at: timestamptz
  id: bigint
  submited_flag: String
  updated_at: timestamptz
  user_id: bigint
}

"""
order by min() on columns of table "submissions"
"""
input submissions_min_order_by {
  challenge_id: order_by
  created_at: order_by
  id: order_by
  submited_flag: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "submissions"
"""
type submissions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [submissions!]!
}

"""
input type for inserting object relation for remote table "submissions"
"""
input submissions_obj_rel_insert_input {
  data: submissions_insert_input!

  """upsert condition"""
  on_conflict: submissions_on_conflict
}

"""
on_conflict condition type for table "submissions"
"""
input submissions_on_conflict {
  constraint: submissions_constraint!
  update_columns: [submissions_update_column!]! = []
  where: submissions_bool_exp
}

"""Ordering options when selecting data from "submissions"."""
input submissions_order_by {
  challenge: challenges_order_by
  challenge_id: order_by
  created_at: order_by
  id: order_by
  score: scores_order_by
  submited_flag: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: submissions"""
input submissions_pk_columns_input {
  id: bigint!
}

"""
select columns of table "submissions"
"""
enum submissions_select_column {
  """column name"""
  challenge_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  submited_flag

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "submissions"
"""
input submissions_set_input {
  challenge_id: bigint
  created_at: timestamptz
  id: bigint
  submited_flag: String
  updated_at: timestamptz
  user_id: bigint
}

"""aggregate stddev on columns"""
type submissions_stddev_fields {
  challenge_id: Float
  id: Float
  user_id: Float
}

"""
order by stddev() on columns of table "submissions"
"""
input submissions_stddev_order_by {
  challenge_id: order_by
  id: order_by
  user_id: order_by
}

"""aggregate stddev_pop on columns"""
type submissions_stddev_pop_fields {
  challenge_id: Float
  id: Float
  user_id: Float
}

"""
order by stddev_pop() on columns of table "submissions"
"""
input submissions_stddev_pop_order_by {
  challenge_id: order_by
  id: order_by
  user_id: order_by
}

"""aggregate stddev_samp on columns"""
type submissions_stddev_samp_fields {
  challenge_id: Float
  id: Float
  user_id: Float
}

"""
order by stddev_samp() on columns of table "submissions"
"""
input submissions_stddev_samp_order_by {
  challenge_id: order_by
  id: order_by
  user_id: order_by
}

"""
Streaming cursor of the table "submissions"
"""
input submissions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: submissions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input submissions_stream_cursor_value_input {
  challenge_id: bigint
  created_at: timestamptz
  id: bigint
  submited_flag: String
  updated_at: timestamptz
  user_id: bigint
}

"""aggregate sum on columns"""
type submissions_sum_fields {
  challenge_id: bigint
  id: bigint
  user_id: bigint
}

"""
order by sum() on columns of table "submissions"
"""
input submissions_sum_order_by {
  challenge_id: order_by
  id: order_by
  user_id: order_by
}

"""
update columns of table "submissions"
"""
enum submissions_update_column {
  """column name"""
  challenge_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  submited_flag

  """column name"""
  updated_at

  """column name"""
  user_id
}

input submissions_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: submissions_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: submissions_set_input

  """filter the rows which have to be updated"""
  where: submissions_bool_exp!
}

"""aggregate var_pop on columns"""
type submissions_var_pop_fields {
  challenge_id: Float
  id: Float
  user_id: Float
}

"""
order by var_pop() on columns of table "submissions"
"""
input submissions_var_pop_order_by {
  challenge_id: order_by
  id: order_by
  user_id: order_by
}

"""aggregate var_samp on columns"""
type submissions_var_samp_fields {
  challenge_id: Float
  id: Float
  user_id: Float
}

"""
order by var_samp() on columns of table "submissions"
"""
input submissions_var_samp_order_by {
  challenge_id: order_by
  id: order_by
  user_id: order_by
}

"""aggregate variance on columns"""
type submissions_variance_fields {
  challenge_id: Float
  id: Float
  user_id: Float
}

"""
order by variance() on columns of table "submissions"
"""
input submissions_variance_order_by {
  challenge_id: order_by
  id: order_by
  user_id: order_by
}

type subscription_root {
  """An array relationship"""
  bans(
    """distinct select on columns"""
    distinct_on: [bans_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bans_order_by!]

    """filter the rows returned"""
    where: bans_bool_exp
  ): [bans!]!

  """An aggregate relationship"""
  bans_aggregate(
    """distinct select on columns"""
    distinct_on: [bans_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bans_order_by!]

    """filter the rows returned"""
    where: bans_bool_exp
  ): bans_aggregate!

  """fetch data from the table: "bans" using primary key columns"""
  bans_by_pk(id: bigint!): bans

  """
  fetch data from the table in a streaming manner: "bans"
  """
  bans_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [bans_stream_cursor_input]!

    """filter the rows returned"""
    where: bans_bool_exp
  ): [bans!]!

  """An array relationship"""
  challenges(
    """distinct select on columns"""
    distinct_on: [challenges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenges_order_by!]

    """filter the rows returned"""
    where: challenges_bool_exp
  ): [challenges!]!

  """An aggregate relationship"""
  challenges_aggregate(
    """distinct select on columns"""
    distinct_on: [challenges_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [challenges_order_by!]

    """filter the rows returned"""
    where: challenges_bool_exp
  ): challenges_aggregate!

  """fetch data from the table: "challenges" using primary key columns"""
  challenges_by_pk(id: bigint!): challenges

  """
  fetch data from the table in a streaming manner: "challenges"
  """
  challenges_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [challenges_stream_cursor_input]!

    """filter the rows returned"""
    where: challenges_bool_exp
  ): [challenges!]!

  """
  fetch data from the table: "machines"
  """
  machines(
    """distinct select on columns"""
    distinct_on: [machines_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [machines_order_by!]

    """filter the rows returned"""
    where: machines_bool_exp
  ): [machines!]!

  """
  fetch aggregated fields from the table: "machines"
  """
  machines_aggregate(
    """distinct select on columns"""
    distinct_on: [machines_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [machines_order_by!]

    """filter the rows returned"""
    where: machines_bool_exp
  ): machines_aggregate!

  """fetch data from the table: "machines" using primary key columns"""
  machines_by_pk(id: bigint!): machines

  """
  fetch data from the table in a streaming manner: "machines"
  """
  machines_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [machines_stream_cursor_input]!

    """filter the rows returned"""
    where: machines_bool_exp
  ): [machines!]!

  """An array relationship"""
  scores(
    """distinct select on columns"""
    distinct_on: [scores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scores_order_by!]

    """filter the rows returned"""
    where: scores_bool_exp
  ): [scores!]!

  """An aggregate relationship"""
  scores_aggregate(
    """distinct select on columns"""
    distinct_on: [scores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scores_order_by!]

    """filter the rows returned"""
    where: scores_bool_exp
  ): scores_aggregate!

  """fetch data from the table: "scores" using primary key columns"""
  scores_by_pk(id: bigint!): scores

  """
  fetch data from the table in a streaming manner: "scores"
  """
  scores_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [scores_stream_cursor_input]!

    """filter the rows returned"""
    where: scores_bool_exp
  ): [scores!]!

  """An array relationship"""
  submissions(
    """distinct select on columns"""
    distinct_on: [submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submissions_order_by!]

    """filter the rows returned"""
    where: submissions_bool_exp
  ): [submissions!]!

  """An aggregate relationship"""
  submissions_aggregate(
    """distinct select on columns"""
    distinct_on: [submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submissions_order_by!]

    """filter the rows returned"""
    where: submissions_bool_exp
  ): submissions_aggregate!

  """fetch data from the table: "submissions" using primary key columns"""
  submissions_by_pk(id: bigint!): submissions

  """
  fetch data from the table in a streaming manner: "submissions"
  """
  submissions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [submissions_stream_cursor_input]!

    """filter the rows returned"""
    where: submissions_bool_exp
  ): [submissions!]!

  """
  fetch data from the table: "teams"
  """
  teams(
    """distinct select on columns"""
    distinct_on: [teams_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teams_order_by!]

    """filter the rows returned"""
    where: teams_bool_exp
  ): [teams!]!

  """
  fetch aggregated fields from the table: "teams"
  """
  teams_aggregate(
    """distinct select on columns"""
    distinct_on: [teams_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teams_order_by!]

    """filter the rows returned"""
    where: teams_bool_exp
  ): teams_aggregate!

  """fetch data from the table: "teams" using primary key columns"""
  teams_by_pk(id: bigint!): teams

  """
  fetch data from the table in a streaming manner: "teams"
  """
  teams_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [teams_stream_cursor_input]!

    """filter the rows returned"""
    where: teams_bool_exp
  ): [teams!]!

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: bigint!): users

  """
  fetch data from the table in a streaming manner: "users"
  """
  users_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [users_stream_cursor_input]!

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!
}

"""Teams Data"""
type teams {
  created_at: timestamptz!
  id: bigint!
  join_code: String!
  name: String!

  """An array relationship"""
  scores(
    """distinct select on columns"""
    distinct_on: [scores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scores_order_by!]

    """filter the rows returned"""
    where: scores_bool_exp
  ): [scores!]!

  """An aggregate relationship"""
  scores_aggregate(
    """distinct select on columns"""
    distinct_on: [scores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scores_order_by!]

    """filter the rows returned"""
    where: scores_bool_exp
  ): scores_aggregate!
  updated_at: timestamptz!

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!
}

"""
aggregated selection of "teams"
"""
type teams_aggregate {
  aggregate: teams_aggregate_fields
  nodes: [teams!]!
}

"""
aggregate fields of "teams"
"""
type teams_aggregate_fields {
  avg: teams_avg_fields
  count(columns: [teams_select_column!], distinct: Boolean): Int!
  max: teams_max_fields
  min: teams_min_fields
  stddev: teams_stddev_fields
  stddev_pop: teams_stddev_pop_fields
  stddev_samp: teams_stddev_samp_fields
  sum: teams_sum_fields
  var_pop: teams_var_pop_fields
  var_samp: teams_var_samp_fields
  variance: teams_variance_fields
}

"""aggregate avg on columns"""
type teams_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "teams". All fields are combined with a logical 'AND'.
"""
input teams_bool_exp {
  _and: [teams_bool_exp!]
  _not: teams_bool_exp
  _or: [teams_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: bigint_comparison_exp
  join_code: String_comparison_exp
  name: String_comparison_exp
  scores: scores_bool_exp
  scores_aggregate: scores_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
  users: users_bool_exp
  users_aggregate: users_aggregate_bool_exp
}

"""
unique or primary key constraints on table "teams"
"""
enum teams_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  teams_name_key

  """
  unique or primary key constraint on columns "id"
  """
  teams_pkey
}

"""
input type for incrementing numeric columns in table "teams"
"""
input teams_inc_input {
  id: bigint
}

"""
input type for inserting data into table "teams"
"""
input teams_insert_input {
  created_at: timestamptz
  id: bigint
  join_code: String
  name: String
  scores: scores_arr_rel_insert_input
  updated_at: timestamptz
  users: users_arr_rel_insert_input
}

"""aggregate max on columns"""
type teams_max_fields {
  created_at: timestamptz
  id: bigint
  join_code: String
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type teams_min_fields {
  created_at: timestamptz
  id: bigint
  join_code: String
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "teams"
"""
type teams_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [teams!]!
}

"""
input type for inserting object relation for remote table "teams"
"""
input teams_obj_rel_insert_input {
  data: teams_insert_input!

  """upsert condition"""
  on_conflict: teams_on_conflict
}

"""
on_conflict condition type for table "teams"
"""
input teams_on_conflict {
  constraint: teams_constraint!
  update_columns: [teams_update_column!]! = []
  where: teams_bool_exp
}

"""Ordering options when selecting data from "teams"."""
input teams_order_by {
  created_at: order_by
  id: order_by
  join_code: order_by
  name: order_by
  scores_aggregate: scores_aggregate_order_by
  updated_at: order_by
  users_aggregate: users_aggregate_order_by
}

"""primary key columns input for table: teams"""
input teams_pk_columns_input {
  id: bigint!
}

"""
select columns of table "teams"
"""
enum teams_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  join_code

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "teams"
"""
input teams_set_input {
  created_at: timestamptz
  id: bigint
  join_code: String
  name: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type teams_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type teams_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type teams_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "teams"
"""
input teams_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: teams_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input teams_stream_cursor_value_input {
  created_at: timestamptz
  id: bigint
  join_code: String
  name: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type teams_sum_fields {
  id: bigint
}

"""
update columns of table "teams"
"""
enum teams_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  join_code

  """column name"""
  name

  """column name"""
  updated_at
}

input teams_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: teams_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: teams_set_input

  """filter the rows which have to be updated"""
  where: teams_bool_exp!
}

"""aggregate var_pop on columns"""
type teams_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type teams_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type teams_variance_fields {
  id: Float
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""Users Data"""
type users {
  """An array relationship"""
  bans(
    """distinct select on columns"""
    distinct_on: [bans_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bans_order_by!]

    """filter the rows returned"""
    where: bans_bool_exp
  ): [bans!]!

  """An aggregate relationship"""
  bans_aggregate(
    """distinct select on columns"""
    distinct_on: [bans_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bans_order_by!]

    """filter the rows returned"""
    where: bans_bool_exp
  ): bans_aggregate!
  created_at: timestamptz!
  email: String!
  email_verification_code: String!
  first_name: String!
  hash: String!
  id: bigint!
  is_admin: Boolean!
  is_email_verified: Boolean!
  last_name: String!
  salt: String!

  """An array relationship"""
  scores(
    """distinct select on columns"""
    distinct_on: [scores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scores_order_by!]

    """filter the rows returned"""
    where: scores_bool_exp
  ): [scores!]!

  """An aggregate relationship"""
  scores_aggregate(
    """distinct select on columns"""
    distinct_on: [scores_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [scores_order_by!]

    """filter the rows returned"""
    where: scores_bool_exp
  ): scores_aggregate!

  """An array relationship"""
  submissions(
    """distinct select on columns"""
    distinct_on: [submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submissions_order_by!]

    """filter the rows returned"""
    where: submissions_bool_exp
  ): [submissions!]!

  """An aggregate relationship"""
  submissions_aggregate(
    """distinct select on columns"""
    distinct_on: [submissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [submissions_order_by!]

    """filter the rows returned"""
    where: submissions_bool_exp
  ): submissions_aggregate!

  """An object relationship"""
  team: teams
  team_id: bigint
  updated_at: timestamptz!
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

input users_aggregate_bool_exp {
  bool_and: users_aggregate_bool_exp_bool_and
  bool_or: users_aggregate_bool_exp_bool_or
  count: users_aggregate_bool_exp_count
}

input users_aggregate_bool_exp_bool_and {
  arguments: users_select_column_users_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: users_bool_exp
  predicate: Boolean_comparison_exp!
}

input users_aggregate_bool_exp_bool_or {
  arguments: users_select_column_users_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: users_bool_exp
  predicate: Boolean_comparison_exp!
}

input users_aggregate_bool_exp_count {
  arguments: [users_select_column!]
  distinct: Boolean
  filter: users_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  avg: users_avg_fields
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
  stddev: users_stddev_fields
  stddev_pop: users_stddev_pop_fields
  stddev_samp: users_stddev_samp_fields
  sum: users_sum_fields
  var_pop: users_var_pop_fields
  var_samp: users_var_samp_fields
  variance: users_variance_fields
}

"""
order by aggregate values of table "users"
"""
input users_aggregate_order_by {
  avg: users_avg_order_by
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
  stddev: users_stddev_order_by
  stddev_pop: users_stddev_pop_order_by
  stddev_samp: users_stddev_samp_order_by
  sum: users_sum_order_by
  var_pop: users_var_pop_order_by
  var_samp: users_var_samp_order_by
  variance: users_variance_order_by
}

"""
input type for inserting array relation for remote table "users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""aggregate avg on columns"""
type users_avg_fields {
  id: Float
  team_id: Float
}

"""
order by avg() on columns of table "users"
"""
input users_avg_order_by {
  id: order_by
  team_id: order_by
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  bans: bans_bool_exp
  bans_aggregate: bans_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  email_verification_code: String_comparison_exp
  first_name: String_comparison_exp
  hash: String_comparison_exp
  id: bigint_comparison_exp
  is_admin: Boolean_comparison_exp
  is_email_verified: Boolean_comparison_exp
  last_name: String_comparison_exp
  salt: String_comparison_exp
  scores: scores_bool_exp
  scores_aggregate: scores_aggregate_bool_exp
  submissions: submissions_bool_exp
  submissions_aggregate: submissions_aggregate_bool_exp
  team: teams_bool_exp
  team_id: bigint_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  users_email_key

  """
  unique or primary key constraint on columns "hash"
  """
  users_hash_key

  """
  unique or primary key constraint on columns "id"
  """
  users_pkey

  """
  unique or primary key constraint on columns "salt"
  """
  users_salt_key
}

"""
input type for incrementing numeric columns in table "users"
"""
input users_inc_input {
  id: bigint
  team_id: bigint
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  bans: bans_arr_rel_insert_input
  created_at: timestamptz
  email: String
  email_verification_code: String
  first_name: String
  hash: String
  id: bigint
  is_admin: Boolean
  is_email_verified: Boolean
  last_name: String
  salt: String
  scores: scores_arr_rel_insert_input
  submissions: submissions_arr_rel_insert_input
  team: teams_obj_rel_insert_input
  team_id: bigint
  updated_at: timestamptz
}

"""aggregate max on columns"""
type users_max_fields {
  created_at: timestamptz
  email: String
  email_verification_code: String
  first_name: String
  hash: String
  id: bigint
  last_name: String
  salt: String
  team_id: bigint
  updated_at: timestamptz
}

"""
order by max() on columns of table "users"
"""
input users_max_order_by {
  created_at: order_by
  email: order_by
  email_verification_code: order_by
  first_name: order_by
  hash: order_by
  id: order_by
  last_name: order_by
  salt: order_by
  team_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type users_min_fields {
  created_at: timestamptz
  email: String
  email_verification_code: String
  first_name: String
  hash: String
  id: bigint
  last_name: String
  salt: String
  team_id: bigint
  updated_at: timestamptz
}

"""
order by min() on columns of table "users"
"""
input users_min_order_by {
  created_at: order_by
  email: order_by
  email_verification_code: order_by
  first_name: order_by
  hash: order_by
  id: order_by
  last_name: order_by
  salt: order_by
  team_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
on_conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"""Ordering options when selecting data from "users"."""
input users_order_by {
  bans_aggregate: bans_aggregate_order_by
  created_at: order_by
  email: order_by
  email_verification_code: order_by
  first_name: order_by
  hash: order_by
  id: order_by
  is_admin: order_by
  is_email_verified: order_by
  last_name: order_by
  salt: order_by
  scores_aggregate: scores_aggregate_order_by
  submissions_aggregate: submissions_aggregate_order_by
  team: teams_order_by
  team_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: users"""
input users_pk_columns_input {
  id: bigint!
}

"""
select columns of table "users"
"""
enum users_select_column {
  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  email_verification_code

  """column name"""
  first_name

  """column name"""
  hash

  """column name"""
  id

  """column name"""
  is_admin

  """column name"""
  is_email_verified

  """column name"""
  last_name

  """column name"""
  salt

  """column name"""
  team_id

  """column name"""
  updated_at
}

"""
select "users_aggregate_bool_exp_bool_and_arguments_columns" columns of table "users"
"""
enum users_select_column_users_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_admin

  """column name"""
  is_email_verified
}

"""
select "users_aggregate_bool_exp_bool_or_arguments_columns" columns of table "users"
"""
enum users_select_column_users_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_admin

  """column name"""
  is_email_verified
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  created_at: timestamptz
  email: String
  email_verification_code: String
  first_name: String
  hash: String
  id: bigint
  is_admin: Boolean
  is_email_verified: Boolean
  last_name: String
  salt: String
  team_id: bigint
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type users_stddev_fields {
  id: Float
  team_id: Float
}

"""
order by stddev() on columns of table "users"
"""
input users_stddev_order_by {
  id: order_by
  team_id: order_by
}

"""aggregate stddev_pop on columns"""
type users_stddev_pop_fields {
  id: Float
  team_id: Float
}

"""
order by stddev_pop() on columns of table "users"
"""
input users_stddev_pop_order_by {
  id: order_by
  team_id: order_by
}

"""aggregate stddev_samp on columns"""
type users_stddev_samp_fields {
  id: Float
  team_id: Float
}

"""
order by stddev_samp() on columns of table "users"
"""
input users_stddev_samp_order_by {
  id: order_by
  team_id: order_by
}

"""
Streaming cursor of the table "users"
"""
input users_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: users_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input users_stream_cursor_value_input {
  created_at: timestamptz
  email: String
  email_verification_code: String
  first_name: String
  hash: String
  id: bigint
  is_admin: Boolean
  is_email_verified: Boolean
  last_name: String
  salt: String
  team_id: bigint
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type users_sum_fields {
  id: bigint
  team_id: bigint
}

"""
order by sum() on columns of table "users"
"""
input users_sum_order_by {
  id: order_by
  team_id: order_by
}

"""
update columns of table "users"
"""
enum users_update_column {
  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  email_verification_code

  """column name"""
  first_name

  """column name"""
  hash

  """column name"""
  id

  """column name"""
  is_admin

  """column name"""
  is_email_verified

  """column name"""
  last_name

  """column name"""
  salt

  """column name"""
  team_id

  """column name"""
  updated_at
}

input users_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: users_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: users_set_input

  """filter the rows which have to be updated"""
  where: users_bool_exp!
}

"""aggregate var_pop on columns"""
type users_var_pop_fields {
  id: Float
  team_id: Float
}

"""
order by var_pop() on columns of table "users"
"""
input users_var_pop_order_by {
  id: order_by
  team_id: order_by
}

"""aggregate var_samp on columns"""
type users_var_samp_fields {
  id: Float
  team_id: Float
}

"""
order by var_samp() on columns of table "users"
"""
input users_var_samp_order_by {
  id: order_by
  team_id: order_by
}

"""aggregate variance on columns"""
type users_variance_fields {
  id: Float
  team_id: Float
}

"""
order by variance() on columns of table "users"
"""
input users_variance_order_by {
  id: order_by
  team_id: order_by
}